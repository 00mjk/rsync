#!/usr/bin/perl -w
# This script is used to turn one or more of the "patch/*" branches
# into one or more diffs in the "patches" directory.  Pass the option
# --gen if you want generated files in the diffs.  Pass the name of
# one or more diffs if you want to just update a subset of all the
# diffs.

use strict;

my $patches_dir = 'patches';
my $incl_generated_files;

if (@ARGV && $ARGV[0] =~ /^--gen(?:=(\S+))?$/) {
    $patches_dir = $1 if defined $1;
    $incl_generated_files = 1;
    shift;
}

die "No '$patches_dir' directory was found.\n" unless -d $patches_dir;
die "No '.git' directory present in the current dir.\n" unless -d '.git';

my @extra_files;
open(IN, '<', 'Makefile.in') or die "Couldn't open Makefile.in: $!\n";
while (<IN>) {
    if (s/^GENFILES=//) {
	while (s/\\$//) {
	    $_ .= <IN>;
	}
	@extra_files = split(' ', $_);
	last;
    }
}
close IN;

system "git checkout master" and exit 1;
if ($incl_generated_files) {
    die "'a' must not exist in the current directory.\n" if -e 'a';
    die "'b' must not exist in the current directory.\n" if -e 'b';
    system "./config.status Makefile && make gen && rsync -a @extra_files a/" and exit 1;
}
my $last_touch = time;

my(@patches, %local_patch);
if (@ARGV) {
    foreach (@ARGV) {
	s{^(patches|patch|origin/patch)/} {};
	s{\.diff$} {};
	push(@patches, $_);
    }
    open(PIPE, '-|', 'git', 'branch', '-l') or die $!;
} else {
    open(PIPE, '-|', 'git', 'branch', '-a') or die $!;
}
while (<PIPE>) {
    if (m# origin/patch/(.*)#) {
	push(@patches, $1);
    } elsif (m# patch/(.*)#) {
	$local_patch{$1} = 1;
    }
}
close PIPE;

my(%parent, %description);
foreach my $patch (@patches) {
    my $branch = ($local_patch{$patch} ? '' : 'origin/') . "patch/$patch";
    my $desc = '';
    open(PIPE, '-|', 'git', 'diff', '-U1000', "master...$branch", '--', "PATCH.$patch") or die $!;
    while (<PIPE>) {
	last if /^@@ /;
    }
    while (<PIPE>) {
	next unless s/^[ +]//;
	if (m#patch -p1 <patches/(\S+)\.diff# && $1 ne $patch) {
	    $parent{$patch} = $1;
	}
	$desc .= $_;
    }
    $description{$patch} = $desc;
}

my %completed;
foreach my $patch (@patches) {
    next if $completed{$patch}++;
    update_patch($patch);
}

if ($incl_generated_files) {
    system "rm -rf a b";
}

sleep 1 if $last_touch == time;
system "git checkout master";

exit;


sub update_patch
{
    my($patch) = @_;

    my $parent = $parent{$patch};
    if (defined $parent) {
	unless ($completed{$parent}++) {
	    update_patch($parent);
	}
	$parent = "patch/$parent";
    } else {
	$parent = 'master';
    }

    print "======== $patch ========\n";

    sleep 1 if $incl_generated_files && $last_touch == time;
    if ($local_patch{$patch}) {
	system "git checkout patch/$patch" and exit 1;
    } else {
	system "git checkout --track -b patch/$patch origin/patch/$patch" and exit 1;
    }

    open(OUT, '>', "$patches_dir/$patch.diff") or die $!;
    print OUT $description{$patch}, "\n";

    if (system("git rebase -m $parent") != 0) {
	print qq|"git rebase -m $parent" incomplete -- please fix.\n|;
	$ENV{PS1} = "[$parent] patch/$patch: ";
	system $ENV{SHELL} and exit 1;
    }

    if ($incl_generated_files) {
	system "./config.status Makefile && make gen && rsync -a @extra_files b/" and exit 1;
    }
    $last_touch = time;

    open(PIPE, '-|', 'git', 'diff', $parent) or die $!;
    DIFF: while (<PIPE>) {
	while (m{^diff --git a/PATCH}) {
	    while (<PIPE>) {
		last if m{^diff --git a/};
	    }
	    last DIFF if !defined $_;
	}
	next if /^index /;
	print OUT $_;
    }
    close PIPE;

    if ($incl_generated_files) {
	open(PIPE, '-|', 'diff', '-up', 'a', 'b') or die $!;
	while (<PIPE>) {
	    s/^((?:---|\+\+\+) [^\t]+)\t.*/$1/;
	    print OUT $_;
	}
	close PIPE;
    }

    close OUT;
}
